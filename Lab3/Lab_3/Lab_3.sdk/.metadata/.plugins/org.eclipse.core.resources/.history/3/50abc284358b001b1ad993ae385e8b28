/*--------------------------------------------------------------------
-- Name:	Brandon S. Ramos
-- Date:	3/15/2021
-- Course: 	CSCE 436: Advanced Embedded Systems
-- File: 	Lab3.c
-- Project: Lab 3: Software control of a datapath
-- Pupr:	MicroBlaze c code for Lab 3
--
-- Documentation:	Reveived help by Prof. Falkinburg
--                                   TA Jacob Fox
--
-- Academic Integrity Statement: I certify that, while others may have
-- assisted me in brain storming, debugging and validating this program,
-- the program itself is my own work. I understand that submitting code
-- which is the work of other individuals is a violation of the honor
-- code.  I also understand that if I knowingly give my original work to
-- another individual is also a violation of the honor code.
-------------------------------------------------------------------------*/
/***************************** Include Files ********************************/

#include "xparameters.h"
#include "stdio.h"
#include "xstatus.h"

#include "platform.h"
#include "xil_printf.h"						// Contains xil_printf
#include <xuartlite_l.h>					// Contains XUartLite_RecvByte
#include <xil_io.h>							// Contains Xil_Out8 and its variations
#include <xil_exception.h>

/************************** Constant Definitions ****************************/

/*
 * The following constants define the slave registers used for our Counter PCORE
 */
#define oScopeBase		0x44a00000
#define LbusReg			oScopeBase			//16 LSBs of slv_reg0 are Left Bus
#define	RbusReg			oScopeBase+0x4		//16 LSBs of slv_reg1 are Right Bus
#define	exSelReg		oScopeBase+0x8		//1 LSBs of slv_reg2 is for exSel
#define	exWrAddrReg		oScopeBase+0xc		//10 LSBs of slv_reg3 are for exWrAddr
#define	exWenReg		oScopeBase+0x10		//1 LSBs of slv_reg4 are for exWren
#define	flagReg			oScopeBase+0x14		//3 LSBs of slv_reg5 are ready, v_sync and max_count
	#define readyBit		0x4
	#define v_syncBit		0x2
	#define max_countBit	0x1
#define	reg6			oScopeBase+0x18
#define	triggerTimeReg	oScopeBase+0x1c		//10 LSBs of slv_reg7 is triggerTime
#define	triggerVoltReg 	oScopeBase+0x20      //10 LSBs of slv_reg8 is triggerVolt
#define	exLBusOutReg	oScopeBase+0x24		//16 LSB of slv_reg9 is exLBus to the hardware
#define	exRBusOutReg	oScopeBase+0x28		//16 LSB of slv_reg10 is exrBus to the hardware
#define	ch1Reg			oScopeBase+0x2c		//1 LSB of slv_reg11 is for ch1 enable
#define	ch2Reg			oScopeBase+0x30		//1 LSB of slv_reg12 is for ch2 enable
#define	reg13	oScopeBase+0x34
#define	reg14	oScopeBase+0x38


/*
 * The following constants define the Counter commands
 */
//#define count_HOLD		0x00		// The control bits are defined in the VHDL
//#define	count_COUNT		0x01		// code contained in lec18.vhdl.  They are
//#define	count_LOAD		0x02		// added here to centralize the bit values in
//#define count_RESET		0x03		// a single place.

#define printf xil_printf			/* A smaller footprint printf */

#define	uartRegAddr			0x40600000		// read <= RX, write => TX
//#define Lab2InternalEnableDisable 0;

/************************** Function Prototypes ****************************/
//void myISR(void);

/************************** Variable Definitions **************************/
/*
 * The following are declared globally so they are zeroed and so they are
 * easily accessible from a debugger
 */

//u16 isrCount = 0;
u8 ch1En = 1;
u8 ch2En = 1;
u16 triggerVolt = 220;
u16 triggerTime = 320;
u16 Lbus;
u16 Rbus;
u16 LeftBusArray[1023];

int main(void) {

	unsigned char c;

	init_platform();

	print("Welcome to Lab 3 O-Scope\n\r");
	Xil_Out16(triggerVoltReg,triggerVolt);
	Xil_Out16(triggerTimeReg,triggerTime);
	Xil_Out8(exSelReg,1);

//    microblaze_register_handler((XInterruptHandler) myISR, (void *) 0);
//    microblaze_enable_interrupts();
//
//    Xil_Out8(countClearReg, 0x01);					// Clear the flag and then you MUST
//	Xil_Out8(countClearReg, 0x00);					// allow the flag to be reset later

    while(1) {

    	c=XUartLite_RecvByte(uartRegAddr);

		switch(c) {

    		/*-------------------------------------------------
    		 * Reply with the help menu
    		 *-------------------------------------------------
			 */
    		case '?':
    			printf("--------------------------\r\n");
    			printf(" TriggerTime = %d\r\n",triggerTime);
    			printf(" TriggerVolt = %d\r\n",triggerVolt);
//    			printf(" Flag Register = %x\r\n",);
    			printf(" Left Bus = %x\r\n",Lbus);
    			printf(" Right Bus = %x\r\n",Rbus);



//    			printf("	Lab2Internal Functionality = %x\r\n",Xil_In16(Lab2InternalEnableDisable));
//    			printf("	isr count = %x\r\n",isrCount);
//    			printf("	Roll = %x\r\n",Xil_In16(countRollReg));
//    			printf("	Roll = %x\r\n",Xil_In16(countRollReg));

    			printf("--------------------------\r\n");
    			printf("?: Help Menu\r\n");
    			printf("c: Clear Terminal Window\r\n");
//    			printf("p: Write Sample Wave\r\n");
    			printf("g: Grab Data to Fill Buffer\r\n");
//    			printf("l: Read Lbus\r\n");
//    			printf("r: Read Rbus\r\n");
//    			printf("e/E: Falling/Rising Edge Trigger\r\n");
//    			printf("1/2: Channel 1/2 Trigger\r\n");
//    			printf("f/F: Read/Clear Flag Register\r\n");
    			printf("d: Increase Trigger Time\r\n");
    			printf("a: Decrease Trigger Time\r\n");
    			printf("w: Increase Trigger Volt\r\n");
    			printf("s: Decrease Trigger Volt\r\n");
    			printf("j: Channel 1 Enable/Disable\r\n");
    			printf("k: Channel 2 Enable/Disable\r\n");
    			printf("t: Reset trigger marks\r\n");
//    			printf("i:   Lab 2 Internal Control Enable/Disable");
    			printf("--------------------------\r\n");

    			break;

			/*-------------------------------------------------
			 * Read Left Bus
			 *-------------------------------------------------
			 */
    		case 'g':
    		{
    			int risingEdge = 0;
    			//Grab data to fill left bus array
    			for(int i = 0; i < 1023; i++){
    				u8 ready = 1;
    				while(!ready){
    					 ready = ( (Xil_In8(flagReg) & readyBit) >> (readyBit-1) );

    				}
    				LeftBusArray[i] = (Xil_In16(LbusReg));
    				printf( "%d \r\n",Xil_In16(LbusReg) );
    				Xil_Out16(flagReg, 0x04);
    				Xil_Out16(flagReg, 0x00);
    			}

    			//find trigger intersection
    			for(int i = triggerTime; i < 1023; i++){
    				if((triggerVolt >= LeftBusArray[i-1]) & (triggerVolt < LeftBusArray[i])){ //Look for rising edge
    					risingEdge = i-triggerTime;
    					break; //leave for loop
//    					}

    				}
    			}

    			Xil_Out16(exWenReg,1);

    			for(int i = 20; i < 650; i++){ //map triggerTime to appropriate index

    				Xil_Out16(exWrAddrReg,i);
    				Xil_Out16(exLBusOutReg,LeftBusArray[risingEdge+i]);

    			}
    			Xil_Out16(exWenReg,0);

//    			//Grab data to fill right bus array
//				for(int i = 0; i < 1024; i++){
//					u8 ready = 1;
//					while(!ready){
//						 ready = ( (Xil_In8(flagReg) & readyBit) >> (readyBit-1) );
//
//					}
//					RightBusArray[i] = ( (Xil_In16(RbusReg) >> 6) - 292 );
//					Xil_Out16(flagReg, 0x04);
//					Xil_Out16(flagReg, 0x00);
//				}
    		}
    			break;

//			/*-------------------------------------------------
//			 * Throw out L bus onto scope
//			 *-------------------------------------------------
//			 */
//			case 'x':
//				for(int i = 20; i < 620; i++){
//					u32 ready = ( (Xil_In32(flagReg) & readyBit) >> (readyBit-1) );
//					while(!ready){}
//					Xil_Out16(exLBusOutReg,LeftBusArray[i]);
//				}
//
//				break;


//			/*-------------------------------------------------
//			 * Enable and disable lab 2 internal controls
//			 *-------------------------------------------------
//			 */
//			case 'i':
//				if(Lab2InternalEnableDisable == 0){
//					Xil_Out8(exSel,1);
//					Lab2InternalEnableDisable = 1;
//
//				}else{
//					Xil_Out8(exSel,0);
//					Lab2InternalEnableDisable = 0;
//				}
//				break;

			/*-------------------------------------------------
			 * Ch1 Enable/Disable
			 *-------------------------------------------------
			 */
			case 'j':
				if((ch1En = 0)){
					ch1En = 1;
					Xil_Out8(ch1Reg,ch1En);
				}else{
					ch1En = 0;
					Xil_Out8(ch1Reg,ch1En);
				}

				break;

			/*-------------------------------------------------
			 * Ch2 Enable/Disable
			 *-------------------------------------------------
			 */
			case 'k':
				if((ch2En = 0)){
					ch2En = 1;
					Xil_Out8(ch1Reg,ch2En);
				}else{
					ch2En = 0;
					Xil_Out8(ch1Reg,ch2En);
				}

				break;

			/*-------------------------------------------------
			 * Move triggerVolt mark up
			 *-------------------------------------------------
			 */
			case 'w':
				if(triggerVolt - 10 >= 20){
					triggerVolt -= 10;
					Xil_Out16(triggerVoltReg,triggerVolt);
				}
				break;

			/*-------------------------------------------------
			 * Move triggerVolt mark down
			 *-------------------------------------------------
			 */
			case 's':
				if(triggerVolt + 10 <= 420){
					triggerVolt += 10;
					Xil_Out16(triggerVoltReg,triggerVolt);

				}
				break;

			/*-------------------------------------------------
			 * Move triggerTime mark left
			 *-------------------------------------------------
			 */
			case 'a':
				if(triggerTime - 10 >= 20){
					triggerTime -= 10;
					Xil_Out16(triggerTimeReg,triggerTime);

				}
				break;

			/*-------------------------------------------------
			 * Move triggerTime mark right
			 *-------------------------------------------------
			 */
			case 'd':
				if(triggerVolt + 10 <= 620){
					triggerTime += 10;
					Xil_Out16(triggerTimeReg,triggerTime);
				}
				break;

			/*-------------------------------------------------
			 * Reset trigger marks
			 *-------------------------------------------------
			 */
    		case 't':
    			triggerTime = 320;
    			triggerVolt = 220;
    			Xil_Out16(triggerVoltReg,triggerVolt);
    			Xil_Out16(triggerTimeReg,triggerTime);
    			break;

			/*-------------------------------------------------
			 * Start the counter to count up
			 *-------------------------------------------------
			 */
//        	case 'm':
//        		Xil_Out8(countCtrlReg,count_COUNT);
//        		break;

			/*-------------------------------------------------
			 * Stop the counter from counting
			 *-------------------------------------------------
			 */
//        	case 'S':
//        		Xil_Out8(countCtrlReg,count_HOLD);
//        		break;

			/*-------------------------------------------------
			 * Tell the counter to load a value
			 *-------------------------------------------------
			 */
//        	case 'l':
//        		printf("Enter a 0-9 value to store in the counter: ");
//            	c=XUartLite_RecvByte(uartRegAddr) - 0x30;
//        		Xil_Out8(countQReg,c);						// put value into slv_reg1
//        		Xil_Out8(countCtrlReg,count_LOAD);			// load command
//    			printf("%c\r\n",c+0x30);
//        		break;

			/*-------------------------------------------------
			 * Reset the counter
			 *-------------------------------------------------
			 */
//            case 'r':
//            	Xil_Out8(countCtrlReg,count_RESET);				// reset command
//            	break;

			/*-------------------------------------------------
			 * Clear the ISR counter
			 *-------------------------------------------------
//			 */
//			case 'n':
//				isrCount = 0;				// clear ISR Count
//				break;

			/*-------------------------------------------------
			 * Clear the terminal window
			 *-------------------------------------------------
			 */
            case 'c':
            	for (c=0; c<40; c++) printf("\r\n");
               	break;

			/*-------------------------------------------------
			 * Unknown character was
			 *-------------------------------------------------
			 */
    		default:
    			printf("unrecognized character: %c\r\n",c);
    			break;
    	} // end case

    } // end while 1

    cleanup_platform();

    return 0;
} // end main


//void myISR(void) {
////	isrCount = isrCount + 1;
//	Xil_Out8(countClearReg, 0x01);					// Clear the flag and then you MUST
//	Xil_Out8(countClearReg, 0x00);					// allow the flag to be reset later
//}
