# Lab 1 - VGA Synchronization
## CSCE 436 - Advanced Embedded Systems

## By Brandon Ramos

## Table of Contents (not required but makes things easy to read)
1. [Objectives or Purpose](#objectives-or-purpose)
2. [Preliminary Design](#preliminary-design)
 * [Code](#code)
3. [Software flow chart or algorithms](#software-flow-chart-or-algorithms)
 * [Pseudocode](#pseudocode)
4. [Hardware schematic](#hardware-schematic)
5. [Well-formatted code](#well-formatted-code)
6. [Debugging](#debugging)
7. [Testing methodology or results](#testing-methodology-or-results)
8. [Answers to Lab Questions](#answers-to-lab-questions)
8. [Observations and Conclusions](#observations-and-conclusions)
9. [Documentation](#documentation)
 
### Objectives or Purpose
In this lab, you will write a VGA controller in VHDL and implement it on your FPGA development board. 
You will be provided a VGA-to-HDMI module that will automatically format your output for the HDMI output 
port on your development board. This VGA controller will be tasked to generate the display portion of an 
oscilloscope as shown in the figure below. The scope face consists of a white grid, used to measure the 
signals, two trigger markers, and the waveforms. In this lab, the waveforms will be artificially generated 
by your code, but in later labs, the waveforms will be generated by incoming audio waveforms.
![overview of scopeface] (Images/overview.PNG)

### Preliminary design
To start off with the design. We left off with multiple lab 1 files that do most of the work for the programmer.
The rest will be connecting the modules together. Here, we will discuss the progression through the lab and how we
will divide and conquer.

The design of Lab 1 is broken down into separate modules, some of which are provided and some which 
will need to be created. The interconnection of the modules is illustrated in the following schematic. When a 
signal name appears just inside a box, that should should correspond to the name of that signal in the entity 
description. Please note there are a few omissions in the diagram that you should correct as part of
documentation.

![architecture] (Images/arc.PNG)

#### Prelab
Homework 5 is a prelab to the VGA Synchronization lab. In order to get a video set up on any monitor screen, we need
to have some background information on what the standard protocol is. 
Back when CRT TV's were abundant, there were sync and blanking protocols so that the electron beam could have time to 
get ready for the next scan line. We have kept this protocol ever since then
Shown below is the sync times and the index of the pixel where we will need to prepare blanks and ready times for VGA.

#### Sync Times and Pixle Index
![sync and pixle index] (Images/sync.PNG)

Using the image above to proceed with Homework 5 we can now create a rough draft of what the scope face will look like.
Shown in the image below will be the verticle and horizontal lines, hatch marks and trigger marks. The trigger marks will
be only 9 pixles but will be the channels to trigger volt and time.

#### Rough Draft of Scope Face
![scope face] (Images/scope_draw.PNG)

#### Gate Check 1
By BOC Lesson 7, you must have finished setting up the VGA counters to generate the proper rows and
columns on the waveform. This can be shown with waveform screenshots from the VGA testbench showing 
the h count rolling over causing the v count to increment. Be sure to also show both max counts.

![Row and Column Rollover] (Images/column_rollover.PNG)

The picture above shows the rollover for the column counter, this cascades into the row counter.
![roll rollover] (Images/roll_rollover.PNG)
Above is the row counter that is the same entity as the column counter but with more generalized 
constants such as the count limit for the two. In the "Code" section is a code snippet of the counter
module. 

#### Gate Check 2
By BOC Lesson 8, you must have setup the appropriate v_synch, v_blank, h_synch, and h_blank signals 
on the waveform and created the scopeFace module to draw at least one line on the display. 
Include picture of the line on the display and associated .bit file for the scopeFace module proof. 

Additionally, include screenshots of waveforms showing:

Show the h_synch going high, low, and high in relation to h count.
![h sync] (Images/h_sync1.PNG)
![h sync2] (Images/h_sync2.PNG)

Show the v_synch going high, low, and high in relation to v count.
![v sync] (Images/v_sync1.PNG)

Show the blank signals going high, low, and high in relation to v count and h count.
![blank] (Images/blank1.PNG)
![blank2] (Images/blank2.PNG)
![blank3] (Images/blank3.PNG)
![blank4] (Images/blank4.PNG)

Created the scopeFace module to draw at least one line on the display. By the time this was achieved, I had
already created the code in the scopeface telling the fpga what pixels to color in for the grid, hatchmarks 
and trigger/trigger lines.

![one line] (Images/one_line.PNG)

#### Code:

Starting off with a module to count the rows and columns. This is done with an entity that is used twice where we
cascade them together to get a rollover. One is a mod 525 counter and the other is a mod 800 counter.

-----------------------------------------------------------------------------
	  ctrl
      0          hold
      1          Q+1 mod 5
-----------------------------------------------------------------------------
	process(clk)
	begin
		--generic counting module
		if (rising_edge(clk)) then
			if (reset = '0') then
				processQ <= (others => '0');
				rollSynch <= '0';
			elsif ((processQ < countLimit) and (ctrl = '1')) then 
				processQ <= processQ + 1;
				rollSynch <= '0';
			elsif ((processQ = countLimit) and (ctrl = '1')) then
				processQ <= (others => '0');
				rollSynch <= '1';
				rollCombo <= '0';
			end if;
			
			--prepare rollover
			if (processQ = countLimit -1) then
			    rollCombo <= '1';
			end if;
		end if;
	end process;
	
### Software flow chart or algorithms
All coding include a pseudocode flow charts and algorithms defined your code and the algorithms used. 
 Visio or PowerPoint works well for this!

#### Pseudocode:
Insert pseudocode or flowchart here.

### Hardware schematic
#### The VGA Module
The main task is to build the VGA component for Lab1. This component sweeps across the display from 
left to right, and then return to the left side of the next lower row. The VGA interface determines 
the color of each pixel on this journey with the help of the scopeFace component.

	entity vga is
		Port(	clk: in  STD_LOGIC;
			reset_n : in  STD_LOGIC;
			h_sync : out  STD_LOGIC;
			v_sync : out  STD_LOGIC; 
			blank : out  STD_LOGIC;
			r: out STD_LOGIC_VECTOR(7 downto 0);
			g: out STD_LOGIC_VECTOR(7 downto 0);
			b: out STD_LOGIC_VECTOR(7 downto 0);
			trigger_time: in unsigned(9 downto 0);
			trigger_volt: in unsigned (9 downto 0);
			row: out unsigned(9 downto 0);
			column: out unsigned(9 downto 0);
			ch1: in std_logic;
			ch1_enb: in std_logic;
			ch2: in std_logic;
			ch2_enb: in std_logic);
	end vga;

Below is the reference table to the vga entity giving a complete understanding of what each port does

clk:	This is the 25Mhz pixel clock generated by the DCM in the video module.

reset_n:	This is the same active high reset signal passed into the top level Lab1 module.

tr_volt:	This is a 10-bit unsigned value representing the trigger voltage. This value is passed to the 
	scopeFace module so that a yellow arrow (see Trigger Level Marker in the screen show) on the vertical 
	axis.

tr_time:	This is a 10-bit unsigned value representing the trigger time. This value is passed to the scopeFace 
	module so that a yellow arrow (see Trigger Time Marker in the screen show) on the horizontal axis.

ch1:	This 1-bit signal signals the VGA module to draw the channel 1 signal on the scope for this row, 
	column pixel. When the value is 1, draw a yellow pixel on the display at the current row,colum 
	position. When 0, do not draw a pixel.

ch1_enb:	This 1-bit signal enable the ch1 signal to be drawn.

ch2:	This 1-bit signal signals the VGA module to draw the channel 2 signal on the scope for this row,
	column pixel. When the value is 1, draw a green pixel on the display at the current row, column 
	position. When 0, do not draw a pixel.

ch2_enb:	This 1-bit signal enable the ch2 signal to be drawn.

R:	The 8-bit red intensity for this row,column pixel on the screen.

G:	The 8-bit green intensity for this row,column pixel on the screen.

B:	The 8-bit blue intensity for this row,column pixel on the screen.

Row:	The current row being drawn on the display.

Column:	The current row being drawn on the display.

blank:	The blank signal for the current row,column position. Its the logical OR of the h_blank and v_blank 
	signals.

h_synch:	The h_synch signal for the current row,column position.

v_synch:	The v_synch signal for the current row,column position.

Behavior: The VGA component contains a pair of cascaded counters which generate the row and column values of 
	the current pixel being displayed. The row and column values are used to generate the blank, h_synch 
	and v_synch signals according to the Figures above. The scopeFace component (more on this below), 
	takes the row and column values (along with some other information) and generates the R,G,B color of 
	that pixel. The three muxes on the output of the R,G,B output of the scopeFace component output the 
	scopeFace R,G,B values for row,column values within the 640x480 displayable region, or 0's for values 
	outside this region.


#### The scopeFace Module
Inside the VGA module sits an instance of the scopeFace entity. This entity only contains combinational logic. 
When given a row,column pair, its responsible for generating the R,G,B value of that pixel.

	entity scopeFace is
    		Port ( row : in  unsigned(9 downto 0);
           column : in  unsigned(9 downto 0);
			      trigger_volt: in unsigned (9 downto 0);
			  trigger_time: in unsigned (9 downto 0);
           r : out  std_logic_vector(7 downto 0);
           g : out  std_logic_vector(7 downto 0);
           b : out  std_logic_vector(7 downto 0);
			  ch1: in std_logic;
			  ch1_enb: in std_logic;
			  ch2: in std_logic;
			  ch2_enb: in std_logic);
	end scopeFace;

Below will give an understanding on what each I/O port does in the entity.

clk	This is the 25Mhz pixel clock generated by the DCM in the video module.

reset_n	This is the same active high reset signal passed into the top level Lab1 module.

tr_volt	This is a 10-bit unsigned value representing the trigger voltage. This value is passed to 
	the scopeFace module so that a yellow arrow (see Trigger Level Marker in the screen show) 
	on the vertical axis.

tr_time	This is a 10-bit unsigned value representing the trigger time. This value is passed to the 
	scopeFace module so that a yellow arrow (see Trigger Time Marker in the screen show) on the 
	horizontal axis.

ch1	This 1-bit signal signals the VGA module to draw the channel 1 signal on the scope for this row, 
	column pixel. When the value is 1, draw a yellow pixel on the display at the current row,column 
	position. When 0, do not draw a pixel.

ch1_enb	This 1-bit signal enable the ch1 signal to be drawn.

ch2	This 1-bit signal signals the VGA module to draw the channel 2 signal on the scope for this row,
	column pixel. When the value is 1, draw a green pixel on the display at the current row, column 
	position. When 0, do not draw a pixel.

ch2_enb	This 1-bit signal enable the ch2 signal to be drawn.

R	The 8-bit red intensity for this row,column pixel on the screen.

G	The 8-bit green intensity for this row,column pixel on the screen.

B	The 8-bit blue intensity for this row,column pixel on the screen.

Row	The current row being drawn on the display.

Column	The current row being drawn on the display.

Behavior The scopeFace component takes in the current row,column coordinates of the display and 
	generates the R,G,B values at that screen coordinate. For example, if row,column = 20,20 then 
	the R,G,B output should be 0xFF,0xFF,0xFF (white) because the upper left corner of the O'scope 
	grid display is white. Note, you can get the RGB values for common colors at this website or 
	this website.

#### Connecting
The Digilent board will have a lot of connections required to make this lab work.
The image below shows how to made these connections to get the lab to work.
![connecting] (Images/fpga.PNG)


### Debugging
You should be keeping track of issues as you go along.  I didn't have any problems is not 
a good answer.  Describe the problems you had and what you did to fix it.  Again this is where 
I would say commit early and often and start your notebook when you start your code.

### Testing methodology or results
Detail the steps in getting the results you system is designed to achieve.  Have enough detail 
that someone can come behind and reproduce your results.

Display your results and describe them in detail so that anyone can understand.  For example Figure 
1 below shows a screenshot of a memory dump for RAM from 0x0200 to 0x024E.  You will also describe
 to the reader what they are looking at.

##### Figure 1: Memory Dump Label (Always include figure AND table labels!)

### Answers to Lab Questions
Here is where you would answer any lab questions given in the lab writeup.

### Observations and Conclusions
During this whole assignment, what did you learn?  What did you notice that was noteworthy?  This
 should be a paragraph starting with the purpose, whether or not you achieved that purpose, what 
you learned, and how you can use this for future labs.

### Documentation
Further help outside lecture time was provided by Professor Falkinburg and Jacob Fox (TA)