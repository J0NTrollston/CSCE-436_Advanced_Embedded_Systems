# Lab 1 - VGA Synchronization
## CSCE 436 - Advanced Embedded Systems
## By Brandon Ramos

## Table of Contents (not required but makes things easy to read)
1. [Objectives or Purpose](#objectives-or-purpose)
2. [Preliminary Design](#preliminary-design)
 * [Code](#code)
3. [Hardware schematic](#hardware-schematic)
4. [Well-formatted code](#well-formatted-code)
5. [Debugging](#debugging)
6. [Testing methodology or results](#testing-methodology-or-results)
7. [Observations and Conclusions](#observations-and-conclusions)
8. [Documentation](#documentation)
 
### Objectives or Purpose
In this lab, you will write a VGA controller in VHDL and implement it on your FPGA development board. 
You will be provided a VGA-to-HDMI module that will automatically format your output for the HDMI output 
port on your development board. This VGA controller will be tasked to generate the display portion of an 
oscilloscope as shown in the figure below. The scope face consists of a white grid, used to measure the 
signals, two trigger markers, and the waveforms. In this lab, the waveforms will be artificially generated 
by your code, but in later labs, the waveforms will be generated by incoming audio waveforms.
##### Overview of Scopeface
![overview of scopeface] (Images/overview.PNG)

### Preliminary design
To start off with the design. We left off with multiple lab 1 files that do most of the work for the programmer.
The rest will be connecting the modules together. Here, we will discuss the progression through the lab and how we
will divide and conquer.

The design of Lab 1 is broken down into separate modules, some of which are provided and some which 
will need to be created. The interconnection of the modules is illustrated in the following schematic. When a 
signal name appears just inside a box, that should should correspond to the name of that signal in the entity 
description. Please note there are a few omissions in the diagram that you should correct as part of
documentation.

##### Architecture of Lab1
![architecture] (Images/arc.PNG)

#### Prelab
Homework 5 is a prelab to the VGA Synchronization lab. In order to get a video set up on any monitor screen, we need
to have some background information on what the standard protocol is. 
Back when CRT TV's were abundant, there were sync and blanking protocols so that the electron beam could have time to 
get ready for the next scan line. We have kept this protocol ever since then
Shown below is the sync times and the index of the pixel where we will need to prepare blanks and ready times for VGA.

#### Sync Times and Pixle Index
##### Sync and Blanking times
![sync and pixle index] (Images/sync.PNG)

Using the image above to proceed with Homework 5 we can now create a rough draft of what the scope face will look like.
Shown in the image below will be the verticle and horizontal lines, hatch marks and trigger marks. The trigger marks will
be only 9 pixles but will be the channels to trigger volt and time.

#### Rough Draft of Scope Face
##### Scope Face rough draft (prelab)
![scope face] (Images/scope_draw.PNG)

#### Gate Check 1
By BOC Lesson 7, you must have finished setting up the VGA counters to generate the proper rows and
columns on the waveform. This can be shown with waveform screenshots from the VGA testbench showing 
the h count rolling over causing the v count to increment. Be sure to also show both max counts.

##### Column Rollover
![Row and Column Rollover] (Images/column_rollover.PNG)

The picture above shows the rollover for the column counter, this cascades into the row counter.
##### Roll Rollover
![row rollover] (Images/row_rollover.PNG)
Above is the row counter that is the same entity as the column counter but with more generalized 
constants such as the count limit for the two. In the "Code" section is a code snippet of the counter
module. 

#### Gate Check 2
By BOC Lesson 8, you must have setup the appropriate v_synch, v_blank, h_synch, and h_blank signals 
on the waveform and created the scopeFace module to draw at least one line on the display. 
Include picture of the line on the display and associated .bit file for the scopeFace module proof. 

Additionally, include screenshots of waveforms showing:

Show the h_synch going high, low, and high in relation to h count.
##### H sync transition
![h sync] (Images/h_sync1.PNG)
##### H sync transition
![h sync2] (Images/h_sync2.PNG)

Show the v_synch going high, low, and high in relation to v count.
##### V sync transition
![v sync] (Images/v_sync1.PNG)

Show the blank signals going high, low, and high in relation to v count and h count.
##### Blanking transition (1)
![blank] (Images/blank1.PNG)
##### Blanking transition (2)
![blank2] (Images/blank2.PNG)
##### Blanking transition (3)
![blank3] (Images/blank3.PNG)
##### Blanking transition (4)
![blank4] (Images/blank4.PNG)

Created the scopeFace module to draw at least one line on the display. By the time this was achieved, I had
already created the code in the scopeface telling the fpga what pixels to color in for the grid, hatchmarks 
and trigger/trigger lines.

##### Picture of grid pattern working
![one line] (Images/one_line.PNG)

#### Required Functionality
For Required Functionality, the code will generate the white oscilloscope grid pattern shown in the picture
below. Also, there will be two channel traces.
The channel 1 trace (yellow) along a diagonal where (row = column).
The channel 2 trace (green) should be drawn along a diagonal where (row = 440-column).
This test code should be placed in the Lab1 entity.
The code below can be seen in the Lab1 entity on the top level, from there it goes to the scopeFace
module and gets printed out to the screen.

	ch1_wave <= '1' when row = column else '0';
	ch2_wave <= '1' when (row = 440-column) else '0';

##### Complete Grid Pattern
![complete grid] (Images/complete.PNG)

#### A-level functionality
A-level functionality is shown in the Figure in the Lab Overview section at the top of the page. In addition 
to drawing the display, the display must update when one of the buttons is pressed according to the list below.
Pressing the upper directional button (BTNU) once should move the Trigger Level Marker up.
Pressing the lower directional button (BTND) once should move the Trigger Level Marker down.
Pressing the left directional button (BTNL) once should move the Trigger Time Marker left.
Pressing the right directional button (BTNR) once should move the Trigger Time Marker right.
In order to achieve this level of functionality, you will need to implement the Process blocks in the Lab1 
entity in the schematic. The code for this is shown below. For video proof of A-level functionality, the 
documentatin will supply a YouTube link to my channel showing the button-to-trigger movement.

	------------------------------------------------------------------------------
	-- the variable button_activity will contain a '1' in any position which 
	-- has been pressed or released.  The buttons are all nominally 0
	-- and equal to 1 when pressed.
    	-- button_activity <= (old_button xor btn) and btn;
	------------------------------------------------------------------------------
	-- The buttons are all nominally 0 and equal to 1 when pressed.
	--      btn(3) = '1'			Right
	--		btn(1) = '1'			Left
	--		btn(2) = '1'			Down
	--		btn(0) = '1'			Up
	--		btn(4) = '1'			Center
	------------------------------------------------------------------------------	
	process(clk)
	begin
		if (rising_edge(clk)) then
			button_activity <= (old_button xor btn) and btn;
			--Reset trigger
			if (button_activity(4) = '1') then
				trigger_time <= to_unsigned(320,10);
				trigger_volt <= to_unsigned(220,10);
				button_activity <= (others => '0');
				old_button <= (others => '0');
		    --Move trigger right
			elsif (button_activity(3) = '1') then
			     if(trigger_time+10 <= 620) then
			         trigger_time <= trigger_time + 10;
			     end if;
			
		    --Move trigger left
			elsif (button_activity(1) = '1') then
			     if(trigger_time - 10 >= 20) then
				    trigger_time <= trigger_time - 10;
				 end if;
				
		    --Move trigger up
			elsif (button_activity(0) = '1') then
			     if(trigger_volt - 10 >= 20) then
				    trigger_volt <= trigger_volt - 10;
				 end if;
				 
			--Move trigger down
		    elsif (button_activity(2) = '1') then
		      if(trigger_volt + 10 <= 420) then
				trigger_volt <= trigger_volt + 10;
		      end if;
			end if;
			
			old_button <= btn;
		end if;
	end process;

#### Code:

Starting off with a module to count the rows and columns. This is done with an entity that is used twice where we
cascade them together to get a rollover. One is a mod 525 counter and the other is a mod 800 counter.

-----------------------------------------------------------------------------
	  ctrl
      0          hold
      1          Q+1 mod 5
-----------------------------------------------------------------------------
	process(clk)
	begin
		--generic counting module
		if (rising_edge(clk)) then
			if (reset = '0') then
				processQ <= (others => '0');
				rollSynch <= '0';
			elsif ((processQ < countLimit) and (ctrl = '1')) then 
				processQ <= processQ + 1;
				rollSynch <= '0';
			elsif ((processQ = countLimit) and (ctrl = '1')) then
				processQ <= (others => '0');
				rollSynch <= '1';
				rollCombo <= '0';
			end if;
			
			--prepare rollover
			if (processQ = countLimit -1) then
			    rollCombo <= '1';
			end if;
		end if;
	end process;

### Hardware schematic
#### The VGA Module
The main task is to build the VGA component for Lab1. This component sweeps across the display from 
left to right, and then return to the left side of the next lower row. The VGA interface determines 
the color of each pixel on this journey with the help of the scopeFace component.

	entity vga is
		Port(	clk: in  STD_LOGIC;
			reset_n : in  STD_LOGIC;
			h_sync : out  STD_LOGIC;
			v_sync : out  STD_LOGIC; 
			blank : out  STD_LOGIC;
			r: out STD_LOGIC_VECTOR(7 downto 0);
			g: out STD_LOGIC_VECTOR(7 downto 0);
			b: out STD_LOGIC_VECTOR(7 downto 0);
			trigger_time: in unsigned(9 downto 0);
			trigger_volt: in unsigned (9 downto 0);
			row: out unsigned(9 downto 0);
			column: out unsigned(9 downto 0);
			ch1: in std_logic;
			ch1_enb: in std_logic;
			ch2: in std_logic;
			ch2_enb: in std_logic);
	end vga;

Below is the reference table to the vga entity giving a complete understanding of what each port does

clk:	This is the 25Mhz pixel clock generated by the DCM in the video module.

reset_n:	This is the same active high reset signal passed into the top level Lab1 module.

tr_volt:	This is a 10-bit unsigned value representing the trigger voltage. This value is passed to the 
	scopeFace module so that a yellow arrow (see Trigger Level Marker in the screen show) on the vertical 
	axis.

tr_time:	This is a 10-bit unsigned value representing the trigger time. This value is passed to the scopeFace 
	module so that a yellow arrow (see Trigger Time Marker in the screen show) on the horizontal axis.

ch1:	This 1-bit signal signals the VGA module to draw the channel 1 signal on the scope for this row, 
	column pixel. When the value is 1, draw a yellow pixel on the display at the current row,colum 
	position. When 0, do not draw a pixel.

ch1_enb:	This 1-bit signal enable the ch1 signal to be drawn.

ch2:	This 1-bit signal signals the VGA module to draw the channel 2 signal on the scope for this row,
	column pixel. When the value is 1, draw a green pixel on the display at the current row, column 
	position. When 0, do not draw a pixel.

ch2_enb:	This 1-bit signal enable the ch2 signal to be drawn.

R:	The 8-bit red intensity for this row,column pixel on the screen.

G:	The 8-bit green intensity for this row,column pixel on the screen.

B:	The 8-bit blue intensity for this row,column pixel on the screen.

Row:	The current row being drawn on the display.

Column:	The current row being drawn on the display.

blank:	The blank signal for the current row,column position. Its the logical OR of the h_blank and v_blank 
	signals.

h_synch:	The h_synch signal for the current row,column position.

v_synch:	The v_synch signal for the current row,column position.

Behavior: The VGA component contains a pair of cascaded counters which generate the row and column values of 
	the current pixel being displayed. The row and column values are used to generate the blank, h_synch 
	and v_synch signals according to the Figures above. The scopeFace component (more on this below), 
	takes the row and column values (along with some other information) and generates the R,G,B color of 
	that pixel. The three muxes on the output of the R,G,B output of the scopeFace component output the 
	scopeFace R,G,B values for row,column values within the 640x480 displayable region, or 0's for values 
	outside this region.


#### The scopeFace Module
Inside the VGA module sits an instance of the scopeFace entity. This entity only contains combinational logic. 
When given a row,column pair, its responsible for generating the R,G,B value of that pixel.

	entity scopeFace is
    	Port (  row : in  unsigned(9 downto 0);
           	    column : in  unsigned(9 downto 0);
			  	trigger_volt: in unsigned (9 downto 0);
			  	trigger_time: in unsigned (9 downto 0);
           	    r : out  std_logic_vector(7 downto 0);
           	    g : out  std_logic_vector(7 downto 0);
           	    b : out  std_logic_vector(7 downto 0);
			  	ch1: in std_logic;
			  	ch1_enb: in std_logic;
			  	ch2: in std_logic;
			  	ch2_enb: in std_logic);
	end scopeFace;

Below will give an understanding on what each I/O port does in the entity.

clk:	This is the 25Mhz pixel clock generated by the DCM in the video module.

reset_n:	This is the same active high reset signal passed into the top level Lab1 module.

tr_volt:	This is a 10-bit unsigned value representing the trigger voltage. This value is passed to 
	the scopeFace module so that a yellow arrow (see Trigger Level Marker in the screen show) 
	on the vertical axis.

tr_time:	This is a 10-bit unsigned value representing the trigger time. This value is passed to the 
	scopeFace module so that a yellow arrow (see Trigger Time Marker in the screen show) on the 
	horizontal axis.

ch1:	This 1-bit signal signals the VGA module to draw the channel 1 signal on the scope for this row, 
	column pixel. When the value is 1, draw a yellow pixel on the display at the current row,column 
	position. When 0, do not draw a pixel.

ch1_enb:	This 1-bit signal enable the ch1 signal to be drawn.

ch2:	This 1-bit signal signals the VGA module to draw the channel 2 signal on the scope for this row,
	column pixel. When the value is 1, draw a green pixel on the display at the current row, column 
	position. When 0, do not draw a pixel.

ch2_enb:	This 1-bit signal enable the ch2 signal to be drawn.

R:	The 8-bit red intensity for this row,column pixel on the screen.

G:	The 8-bit green intensity for this row,column pixel on the screen.

B:	The 8-bit blue intensity for this row,column pixel on the screen.

Row:	The current row being drawn on the display.

Column:	The current row being drawn on the display.

Behavior: The scopeFace component takes in the current row,column coordinates of the display and 
	generates the R,G,B values at that screen coordinate. For example, if row,column = 20,20 then 
	the R,G,B output should be 0xFF,0xFF,0xFF (white) because the upper left corner of the O'scope 
	grid display is white. Note, you can get the RGB values for common colors at this website or 
	this website.

#### Connecting
The Digilent board will have a lot of connections required to make this lab work.
The image below shows how to made these connections to get the lab to work. The main connections are power,
hdmi to the screen and micro usb to program the device.

##### Image of ports to hook up for testing
![connecting] (Images/fpga.PNG)


### Debugging
There were many issues along the way that had to be dealt with. The first case of debugging I went through
was when I was creating the mod "xxx" counter where there was a generic integer value passed on and would 
count up to that specified number. The problem arised when I cascaded two generic counters together. I needed
one to rollover and count up the next counter. Instead what happened is that it would either count up too
early or too late. This was due to the roll signal that was having a problem with timing. So when the counter
was up to the limit minus one, I would set a rollcombo signal that would get ready to roll the next counter. 
This was an easy fix and would be used from then on.

The next problem was when I was setting the blanking signals. the issue was the timing as well with length of 
blanking, and sync. This was fixed by changing the different values of when the timing was for blanks. I found
that it would typically be off by one since I usually had to only add an "=" sign to my comparison of "<".

My big problem that confused me the most was the initial values of the trigger marks. My intension was to have
the trigger marks set up in the center line of their respective verticle and horizontal lines were, instead
they stayed at the initial marks at zero. My first goal was to go to the top level and change the initial 
value of the marks but that kept them at zero still. So at this point I knew they had to be reset before they
could be printed. So when I created the buttons, I also created a reset signal that put them at their marks.
This was a fix and no problems arised after. 

My last problem was the debouncing of the buttons. To fix this I had to check if the buttons had pull-down
or pull-up resistors and find out how to reset. In lab, we were given a button_activity variable that basically
debounced the buttons for us. It XOR'd old_button and button_activity together to see if anything was changed.
This software debouncing technique is not fullproof, but will work for the most part.

### Testing methodology or results
Some testing to get the scopeface to work can take some time, especially when you build a bit file. Instead,
simulating using a testbench can take less time and show you crutial information such as bus transger and logic
information. The first testing method that was used was in the beginning with gate check 1. To check if the
counter was going up correctly, we simulated and checked out the waveform that was produced with a clock. On 
the other hand when working with trying to get the line drawn on the screen. First thing I did was to make sure
my RGB signal is being outputted properly. Thankfully the simulation is quicker and you are able to see if the
"G" signal is being outputted as x"FF" for a green screen.
The last testing method was with the buttons. This is where we would move the trigger marks and change the x
and y axis for the triggers. To test this I would check again the simulation to see if the trigger values change
+- 10 units. 

### Observations and Conclusions
The purpose of this lab wa to implement a VHDL program on our FPGA to display pixels on the screen for graphing
an O'scope. The VGA to HDMI module will automatically format the output to HDMI. I was able to create the
scope face with trigger marks and hatch marks.

During the project, what I have noticed that was critical to getting the VGA sync done was to make sure the
timing of the signals were on time. Now as long as you were in the give or take one pixle from your blanking
target, you didn't have any problem. Noticing the give in the signal processing, there were students having 
trouble displaying a line on their screen and I can almost guarentee that it came down to timing of the sync,
blank and display signals. Otherwise it could be a bigger problem such as a faulty board. 

Something to take away from this lab would be that the protocol for displaying pixles may be the same, but the
history on where sync and blanking came from is an interesting concept to learn. Given that, creating the code
had to be exact. Using this information that I was given for this lab, I will be able to add on to this with
the soon to be lab 2. 

### Documentation
Further help outside lecture time was provided by Professor Falkinburg and Jacob Fox (TA)
References to the Nexys Video Board Reference Manual such as if a button was pull-down or pull-up.

YouTube link for button-to-trigger movement:
	https://www.youtube.com/watch?v=YQk22W4hNbg